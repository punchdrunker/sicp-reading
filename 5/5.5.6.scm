(load "./5.5.scm")

5.5.6 文面アドレス

; 翻訳系による最適化の最も普通のものの一つは, 変数探索の最適化である.
; これまで実装して来たわれわれの翻訳系は, 評価器計算機のlookup-variable-value演算を使うコードを生成する.
; これは実行時環境でフレーム毎に外へ向って現在束縛している各変数と比較することで変数を探索する.
; この探索はフレームが深く入れ子になっていたり, 変数が多かったりすると高価になる.
; 例えば
(let ((x 3) (y 4))
  (lambda (a b c d e)
    (let ((y (* a b x))
          (z (+ c d x)))
      (* x y z))))
; で返された手続きの作用で, 式(* x y z)を評価する時, xの値を探している問題を考えよう.
; let式はlambda組合せの構文シュガーに過ぎないから, これは
((lambda (x y)
   (lambda (a b c d e)
     ((lambda (y z) (* x y z))
      (* a b x)
      (+ c d x))))
 3
 4)
; と等価である.
; lookup-variable-valueがxを探索する度に, 記号xは(第一のフレームで)yやzとeq?でないか, (第二のフレームで) a, b, c, dやeとeq?でないか決めなければならない.
; ここでわれわれのプログラムはdefineを使わない---変数は lambdaだけで束縛される---と仮定しよう.
; われわれの言語は 静的有効範囲だから, 式の実行環境は式が現れるプログラムの文面の構造と対応する構造を持っている.
; 従って翻訳系は上の式を解析する時,
; 手続きを作用させる度に(* x y z)の変数は現在のフレームから二フレーム外で見つかり,
; そのフレームの最初の変数であると知ることが出来る.

; この事実を新しい変数探索演算lexical-address-lookupを考えて調べることが出来る.
; 引数として環境と二つの数: 何個のフレームを読み過すかを指定するフレーム数(frame number)と,
; そのフレームで何個の変数を読み過すかを指定する変位数(displacement number)からなる文面アドレス(lexical address)をとる.
; lexical-address-lookupは現在の環境から相対的な文面アドレスに格納した変数の値を出す.
; われわれの計算機にlexical-address-lookup演算を追加すると,
; 翻訳系にlookup-variable-valueではなく,
; この演算を使って変数を参照するコードを, 生成させることが出来る.
; 同様に翻訳したコードは, set-variable-value!の代りに lexical-address-set!を使うことが出来る.

; こういうコードを生成するためには, 翻訳系は参照を翻訳しようとする変数の文面アドレスを決めることが出来なければならない.
; プログラム中の変数の文面アドレスは, それがコードのどこにあるかに依存する.
; 例えば次のプログラムで式⟨e1⟩のxのアドレスは(2,0)---二フレーム後方で, そのフレームの最初の変数---である.
; その点でy はアドレス(0,0), cはアドレス(1,2)である.
; 式⟨e2⟩ではxは(1,0), yは(1,1), そしてcは(0,2)である.

((lambda (x y)
   (lambda (a b c d e)
     ((lambda (y z) ⟨e1⟩)
      ⟨e2⟩
      (+ c d x))))
 3
 4)

; 翻訳系に文面アドレスを使ったコードを作り出させる一つの方法は,
; 翻訳時環境 (compile-time environment)というデータ構造を維持することである.
; これは, ある変数アクセス演算を実行する時に, どの変数が実行時環境のどのフレームのどの場所にあるかを覚えておくものである.
; 翻訳時環境は, それぞれが変数のリストを持つフレームのリストである.
; (もちろん, 翻訳時に値は計算しないので, 変数には値は束縛していない.)
; 翻訳時環境はcompileの追加の引数となり, 各コード生成器に渡される.
; compileへのトップレベルでの呼出しは, 空の翻訳時環境を使う.
; lambda本体を翻訳する時, 本体を形成する列が, 拡張した環境で翻訳出来るよう,
; compile-lambda-bodyは翻訳環境を, 手続きのパラメタを含むフレームで拡張する.
; 翻訳の各時点で, compile-variableとcompile-assignmentは適切な文面アドレスを生成するため, 翻訳時環境を使う.

