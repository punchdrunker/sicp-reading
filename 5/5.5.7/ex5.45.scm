; 問題 5.45
; 
; 翻訳したコードの使うスタック演算を, 同じ計算に対する評価器の使うスタック演算と比べると,
; (スタック演算の総数を減らして)速度と(最大スタック深さを減らして)スペースの両方で
; 翻訳系がスタックの使い方を最適化する程度を決めることが出来る.
; この最適化したスタックの使い方を, 同じ計算に対する特殊目的の計算機の性能と比べると,
; 翻訳系の品質のある種の表示が得られる. 
; 
; a. 問題5.27は, 上に示した再帰的階乗手続きによるn!の計算で,
; 評価器が必要とするプッシュの回数と最大スタック深さをnの関数として決めよといった.
; 問題5.14は図5.11に示した特殊目的の階乗計算機で同じ計測をせよといった.
; 今度は翻訳したfactorialを使って同じ解析を行え.
; 
; 翻訳版のプッシュの回数の, 解釈版のプッシュの回数に対する比を求め,
; 最大スタック深さについても同じことを行え.
; n!を計算するのに使う演算の数と, スタック深さはnに線形なので,
; これらの比はnが大きくなるにつれ, 定数に近づく筈である.
; この定数は何か. 同様に特殊目的の計算機のスタック使用と解釈版の使用に対する比を求めよ.
; 
; 特殊目的のコード対解釈されるコードの比を, 翻訳するコード対解釈されるコードの比と比べよ.
; 手で加工した制御コードは, われわれの発達途上の万能目的の翻訳系の作ったものより遥かに優れているので,
; 特殊目的計算機は, 翻訳したコードよりも遥かに優れていることがわかる. 
 


(load "./5.5.ss")
(load "./5.5.7.ss")

; (factorial n)をそれぞれの演算方法で比較してみる

(parse-compiled-code
(compile
  '(define (factorial n)
     (if (= n 1)
       1
       (* (factorial (- n 1)) n)))
  'val
  'return)
)

;(compile-and-go
;  '(define (factorial n)
;     (if (= n 1)
;       1
;       (* (factorial (- n 1)) n))))
;
; 5)
;
;(factorial 5)

;(start-eceval)
;
;(define (factorial n)
;  (if (= n 1)
;    1
;    (* (factorial (- n 1)) n)))
;
;(factorial 5)

; 特殊目的の計算機は fact-machine.scm を実行

; b. 性能において, 手で加工した版に近づくようなコードを生成するのを支援するような翻訳系の改良は何か. 

; * 環境の取り扱いを極力しない
; * オープンコードの利用
